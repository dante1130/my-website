<!DOCTYPE html>
<html lang="en">

<head>
    <title></title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://donte.dev/style.css">
    <link rel="stylesheet" href="https://donte.dev/color/blue.css">

    <link rel="stylesheet" href="https://donte.dev/font-hack-subset.css">

    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="/" style="text-decoration: none;">
                    <div class="logo">
                      
                            Andrew Ho
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://donte.dev">blog</a></li>
            
                <li><a href="https://donte.dev/tags">tags</a></li>
            
                <li><a href="https://donte.dev/archive">archive</a></li>
            
                <li><a href="https://donte.dev/about">about me</a></li>
            
                <li><a href="https://github.com/dante1130" target="_blank" rel="noopener noreferrer">github</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://donte.dev/tetris/">Building Tetris in Rust</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2023-06-23
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://donte.dev/tags/project/">#project</a>&nbsp;
                <a class="post-tag" href="https://donte.dev/tags/tetris/">#tetris</a></span>
    

        
        <div class="post-content">
            <img src="assets/tetris.webp" />
<h2 id="introduction">Introduction</h2>
<p>Recently, I had watched the movie <a href="https://en.wikipedia.org/wiki/Tetris_(film)">Tetris</a>, where it tells the story of how a few parties are in a race for negotiating with the bureaucrats of Soviet Union for a license for Tetris.</p>
<p>Before watching this movie, I did not know that Tetris was that big of a deal back in the days. </p>
<p>I remember playing it on my Nintendo Gameboy Color when I was still little, but as I could not grasp hold of how to play it, I did not understand how could it be fun. </p>
<p>Though, I should've probably known, as the game has some pretty impressive achievements today. </p>
<p>Even after almost 40 years, the game is known by everyone worldwide, and still has an active playerbase. It is available on every platform imaginable, holding the world record for the most ported video game.</p>
<p>Thus, I was interested in building it myself to see what it took for such a simple game to be that timeless.</p>
<h2 id="what-i-used">What I used</h2>
<h3 id="rust">Rust</h3>
<p>As I was learning <a href="https://www.rust-lang.org/">Rust</a>, I felt this was a perfect opportunity to build this in. </p>
<p>The game had simple rules and gameplay that I felt that wouldn't be too difficult before I dig too deep.</p>
<h3 id="sdl2">SDL2</h3>
<p>For rendering, I used <a href="https://github.com/Rust-SDL2/rust-sdl2">SDL2</a>, in which there was a crate that provided Rust bindings for it. </p>
<p>I used SDL2 as I wanted to a simple 2D renderer, I didn't want to use something big like the <a href="https://bevyengine.org/">bevy</a> as it was too much for my needs and I want to built everything mostly from the ground up.</p>
<h3 id="other-libs">Other libs</h3>
<ul>
<li>rand - Random generation</li>
<li>anyhow - Easy error handling</li>
</ul>
<h2 id="implementation">Implementation</h2>
<h3 id="shapes">Shapes</h3>
<p>To define a shape, I implemented it by having an array of 2D coordinate positions.</p>
<p>For example, to create an I block, we can construct one by doing:</p>
<pre data-lang="rs" style="background-color:#2b303b;color:#c0c5ce;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#b48ead;">struct </span><span>Position(</span><span style="color:#b48ead;">i32</span><span>, </span><span style="color:#b48ead;">i32</span><span>);
</span><span>
</span><span style="color:#b48ead;">struct </span><span>Block {
</span><span>    </span><span style="color:#bf616a;">position</span><span>: Position,
</span><span>    </span><span style="color:#bf616a;">shape</span><span>: Vec&lt;Position&gt;,
</span><span>    </span><span style="color:#bf616a;">color</span><span>: Color
</span><span>}
</span><span>
</span><span style="color:#b48ead;">let</span><span> block_i = Block { 
</span><span>    position: (</span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">8</span><span>),
</span><span>    shape: vec![
</span><span>        Position(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>),
</span><span>        Position(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>),
</span><span>        Position(</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">0</span><span>),
</span><span>        Position(</span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">0</span><span>),
</span><span>    ],
</span><span>    color: Color::</span><span style="color:#d08770;">RGB</span><span>(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">255</span><span>, </span><span style="color:#d08770;">255</span><span>)
</span><span>};
</span><span>
</span><span style="color:#65737e;">// O: empty space
</span><span style="color:#65737e;">// X: block
</span><span style="color:#65737e;">//
</span><span style="color:#65737e;">// Output:
</span><span style="color:#65737e;">// O O O O
</span><span style="color:#65737e;">// X X X X
</span><span style="color:#65737e;">// O O O O
</span><span style="color:#65737e;">// O O O O
</span></code></pre>
<p>The tuple <code>Position</code> represent x and y values on a 2D coordinate plane.</p>
<p>So, to define an I block at a horizontal rotation, we can do that by having the x position to be in the range of 0..3 as done above.</p>
<p>The <code>position</code> in the <code>Block</code> struct defines the world-space position of the block.</p>
<p>We can use this to translate the positions of the shapes from local-space to world-space.</p>
<pre data-lang="rs" style="background-color:#2b303b;color:#c0c5ce;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#b48ead;">impl </span><span>Block {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">world_block_positions</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; Vec&lt;Position&gt; {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.shape
</span><span>            .</span><span style="color:#96b5b4;">iter</span><span>()
</span><span>            .</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">local_pos</span><span>| Position(block.position.</span><span style="color:#d08770;">0 </span><span>+ local_pos.</span><span style="color:#d08770;">0</span><span>, 
</span><span>                                      block.position.</span><span style="color:#d08770;">1 </span><span>+ local_pos.</span><span style="color:#d08770;">1</span><span>))
</span><span>            .</span><span style="color:#96b5b4;">collect</span><span>()
</span><span>    }
</span><span>}
</span></code></pre>
<p>So, using the same example above where we defined an I block, the world-position would be:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>(4, 8),
</span><span>(5, 8),
</span><span>(6, 8),
</span><span>(7, 8)
</span></code></pre>
<h3 id="rotations">Rotations</h3>
<p>To handle rotations, I would have an array of the shapes, I am only supporting up to 4 rotation states. We can then increment and decrement an index to cycle through the rotations.</p>
<p>For example, for 2 rotation states for the I block:</p>
<pre data-lang="rs" style="background-color:#2b303b;color:#c0c5ce;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#b48ead;">struct </span><span>Position(</span><span style="color:#b48ead;">i32</span><span>, </span><span style="color:#b48ead;">i32</span><span>);
</span><span>
</span><span style="color:#b48ead;">struct </span><span>Block {
</span><span>    </span><span style="color:#bf616a;">position</span><span>: Position,
</span><span>    </span><span style="color:#bf616a;">shapes</span><span>: [Vec&lt;Position&gt;; 4],
</span><span>    </span><span style="color:#bf616a;">shape_index</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>    </span><span style="color:#bf616a;">color</span><span>: Color
</span><span>}
</span><span>
</span><span style="color:#b48ead;">let</span><span> blocks_i = Block { 
</span><span>    position: (</span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">8</span><span>),
</span><span>    shapes: [
</span><span>        vec![
</span><span>            Position(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>),
</span><span>            Position(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>),
</span><span>            Position(</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">0</span><span>),
</span><span>            Position(</span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">0</span><span>),
</span><span>        ],
</span><span>        vec![
</span><span>            Position(</span><span style="color:#d08770;">2</span><span>, -</span><span style="color:#d08770;">1</span><span>),
</span><span>            Position(</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">0</span><span>),
</span><span>            Position(</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">1</span><span>),
</span><span>            Position(</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">2</span><span>),
</span><span>        ],
</span><span>    ],
</span><span>    shape_index: </span><span style="color:#d08770;">0</span><span>,
</span><span>    color: Color::</span><span style="color:#d08770;">RGB</span><span>(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">255</span><span>, </span><span style="color:#d08770;">255</span><span>),
</span><span>};
</span><span>
</span><span style="color:#65737e;">// O: empty space
</span><span style="color:#65737e;">// X: block
</span><span style="color:#65737e;">//
</span><span style="color:#65737e;">// Output:
</span><span style="color:#65737e;">// O O O O | O O X O
</span><span style="color:#65737e;">// X X X X | O O X O
</span><span style="color:#65737e;">// O O O O | O O X O
</span><span style="color:#65737e;">// O O O O | O O X O
</span></code></pre>
<h3 id="grid">Grid</h3>
<p>The grid is built out of a 2D array, with the values of an optional Color value.</p>
<pre data-lang="rs" style="background-color:#2b303b;color:#c0c5ce;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#b48ead;">struct </span><span>Grid {
</span><span>    </span><span style="color:#bf616a;">position</span><span>: Position,
</span><span>    </span><span style="color:#bf616a;">cells</span><span>: Vec&lt;Vec&lt;Option&lt;Color&gt;&gt;
</span><span style="background-color:#bf616a;color:#2b303b;">}</span><span>
</span></code></pre>
<p>The position here refers to the grid's world position, and defines the position most top-left position of the grid in world-space.</p>
<p>If the value of a cell is <code>None</code>, it means that it is an empty space on the grid.</p>
<p>And then when we lock a block onto the grid, we can use the block's color values to populate the grid at that position.</p>
<h3 id="collisions">Collisions</h3>
<p>As we are working with a 2D grid, collisions are relatively simple.</p>
<p>We can deem anything as colliding if they are in the same position in the grid in world-space.</p>
<p>However, since our grid is in local-space, to index it, we have to normalize our positions to local-space.</p>
<p>To do this, we get the difference from the block and grid positions in world-space.</p>
<pre data-lang="rs" style="background-color:#2b303b;color:#c0c5ce;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#b48ead;">pub enum </span><span>Collision {
</span><span>    None,
</span><span>    Left,
</span><span>    Right,
</span><span>    Top,
</span><span>    Bottom,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>Grid {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">is_colliding</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">block</span><span>: &amp;Block) -&gt; Collision {
</span><span>        </span><span style="color:#b48ead;">for</span><span> block_position in block.</span><span style="color:#96b5b4;">world_block_positions</span><span>() {
</span><span>            </span><span style="color:#b48ead;">let</span><span> x = block_position.</span><span style="color:#d08770;">0 </span><span>- </span><span style="color:#bf616a;">self</span><span>.position.</span><span style="color:#d08770;">0</span><span>;
</span><span>            </span><span style="color:#b48ead;">let</span><span> y = block_position.</span><span style="color:#d08770;">1 </span><span>- </span><span style="color:#bf616a;">self</span><span>.position.</span><span style="color:#d08770;">1</span><span>;
</span><span>        }
</span><span>
</span><span>        Collision::None
</span><span>    }
</span><span>}
</span></code></pre>
<p>Now we have our indexes, we can use it check if at a certain cell position, it has a value, which means it is occupied by a locked block.</p>
<p>To make things simpler, we can define this behaviour as colliding at the bottom position as we assume this to be &quot;stacking&quot;, though it doesn't necessarily have to.</p>
<pre data-lang="rs" style="background-color:#2b303b;color:#c0c5ce;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#b48ead;">pub enum </span><span>Collision {
</span><span>    None,
</span><span>    Left,
</span><span>    Right,
</span><span>    Top,
</span><span>    Bottom,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>Grid {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">is_colliding</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">block</span><span>: &amp;Block) -&gt; Collision {
</span><span>        </span><span style="color:#b48ead;">for</span><span> block_position in block.</span><span style="color:#96b5b4;">world_block_positions</span><span>() {
</span><span>            </span><span style="color:#b48ead;">let</span><span> x = block_position.</span><span style="color:#d08770;">0 </span><span>- </span><span style="color:#bf616a;">self</span><span>.position.</span><span style="color:#d08770;">0</span><span>;
</span><span>            </span><span style="color:#b48ead;">let</span><span> y = block_position.</span><span style="color:#d08770;">1 </span><span>- </span><span style="color:#bf616a;">self</span><span>.position.</span><span style="color:#d08770;">1</span><span>;
</span><span>
</span><span>            </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">self</span><span>.cells[y as </span><span style="color:#b48ead;">usize</span><span>][x as </span><span style="color:#b48ead;">usize</span><span>].</span><span style="color:#96b5b4;">is_some</span><span>()) {
</span><span>                </span><span style="color:#b48ead;">return </span><span>Collision::Bottom;
</span><span>            }
</span><span>        }
</span><span>
</span><span>        Collision::None
</span><span>    }
</span><span>}
</span></code></pre>
<p>Now to check if we are colliding outside the surroundings of the grid, we can just do some bounds checking on the size of the grids.</p>
<pre data-lang="rs" style="background-color:#2b303b;color:#c0c5ce;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#b48ead;">pub enum </span><span>Collision {
</span><span>    None,
</span><span>    Left,
</span><span>    Right,
</span><span>    Top,
</span><span>    Bottom,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>Grid {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">is_colliding</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">block</span><span>: &amp;Block) -&gt; Collision {
</span><span>        </span><span style="color:#b48ead;">for</span><span> block_position in block.</span><span style="color:#96b5b4;">world_block_positions</span><span>() {
</span><span>            </span><span style="color:#b48ead;">let</span><span> x = block_position.</span><span style="color:#d08770;">0 </span><span>- </span><span style="color:#bf616a;">self</span><span>.position.</span><span style="color:#d08770;">0</span><span>;
</span><span>            </span><span style="color:#b48ead;">let</span><span> y = block_position.</span><span style="color:#d08770;">1 </span><span>- </span><span style="color:#bf616a;">self</span><span>.position.</span><span style="color:#d08770;">1</span><span>;
</span><span>
</span><span>            </span><span style="color:#b48ead;">if</span><span> x &lt; </span><span style="color:#d08770;">0 </span><span>{
</span><span>                </span><span style="color:#b48ead;">return </span><span>Collision::Left;
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#b48ead;">if</span><span> x &gt;= </span><span style="color:#bf616a;">self</span><span>.cells[</span><span style="color:#d08770;">0</span><span>].</span><span style="color:#96b5b4;">len</span><span>() as </span><span style="color:#b48ead;">i32 </span><span>{
</span><span>                </span><span style="color:#b48ead;">return </span><span>Collision::Right;
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#b48ead;">if</span><span> y &lt; </span><span style="color:#d08770;">0 </span><span>{
</span><span>                </span><span style="color:#b48ead;">return </span><span>Collision::Top;
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#b48ead;">if</span><span> y &gt;= </span><span style="color:#bf616a;">self</span><span>.cells.</span><span style="color:#96b5b4;">len</span><span>() as </span><span style="color:#b48ead;">i32 
</span><span>                || </span><span style="color:#bf616a;">self</span><span>.cells[y as </span><span style="color:#b48ead;">usize</span><span>][x as </span><span style="color:#b48ead;">usize</span><span>].</span><span style="color:#96b5b4;">is_some</span><span>() {
</span><span>                </span><span style="color:#b48ead;">return </span><span>Collision::Bottom;
</span><span>            }
</span><span>        }
</span><span>
</span><span>        Collision::None
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="shortcomings">Shortcomings</h2>
<p>At this time of writing, the project still has some outstanding issues that has not been addressed.</p>
<p>Perhaps, in the future these will be fixed. But for now, I think the project is fine as it is.</p>
<h3 id="handling-collisions-with-rotations">Handling collisions with rotations</h3>
<p>When rotating blocks, it does not account if the new shape positions will collide with any locked blocks.</p>
<p>As a result, in the event that happens, it will lock the current block in place and replace any position that it may have collided.</p>
<h3 id="extra-space-with-rotations">Extra space with rotations</h3>
<p>As we are storing each rotation state with its positions, this is effectively storing 4 times the amount of memory for each block that we instantiate.</p>
<p>The alternative that I considered was to use an anchor point and use some math to rotate the positions around that.</p>
<p>Though this may be a more complex solution, but you effectively only have to define your shape once, and you have the rest of the rotations already figured out with that algorithm.</p>
<h3 id="some-unfinished-features">Some unfinished features</h3>
<ul>
<li>Hard drop</li>
<li>Hold block</li>
<li>Rendering blocks queue</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>After playing Tetris a few times and building it, I finally understood why Tetris can be addicting for some.</p>
<p>For such a simple game, it has great replayability, and can be quite thrilling to clear multiple rows consecutively to save yourself as you build up enough height.</p>
<p>I had definitely learned a lot building it, though not entirely perfect, but I would say it is minimal but complete. Ultimately, it was worth it.</p>
<p>If you want to have a look or give it a try, here is a link to the GitHub repository: <a href="https://github.com/dante1130/tetris">https://github.com/dante1130/tetris</a></p>

        </div>

        
        <div class="pagination">
            <div class="pagination__title">
                <span class="pagination__title-h">Thanks for reading! Read other posts?</span>
                <hr />
            </div>
            <div class="pagination__buttons">
                    <span class="button previous">
                        <a href="https://donte.dev/immutability/">
                            <span class="button__icon">←</span>&nbsp;
                            <span class="button__text">Immutability and why should you care</span>
                        </a>
                    </span>
                
                </div>
        </div>
    
    </div>

    </div>

    
<footer class="footer">
	<div class="footer__inner">
		<div class="copyright">
			<span>©
				
    2023
 Andrew Ho ::
				<a href=mailto::andrewdante2@gmail.com>andrewdante2@gmail.com</a>
			</span>
		</div>
	</div>
</footer>


</div>
</body>

</html>
